// Geometric Pattern Weaver Generator
// Node setup:
// 1. Grid SOP (base geometry)
// 2. Point Wrangle (this code) for pattern generation
// 3. PolyExtrude for depth
// 4. Normal SOP for proper shading
// 5. Material SOP for rendering

// Parameters to expose in UI
// float seed = ch("seed");                 // Global seed
// int pattern_type = chi("pattern_type");  // Pattern type (0-3)
// float scale = chf("scale");              // Pattern scale
// float complexity = chf("complexity");    // Pattern complexity
// float variation = chf("variation");      // Pattern variation
// vector base_color = chv("base_color");   // Base color
// vector accent_color = chv("accent_color"); // Accent color

// Initialize random seed and position
float seed = ch("seed") + @ptnum;
vector pos = @P;

// Pattern generation functions
float generateIslamicPattern(vector p, float scale, float seed) {
    float angle = atan2(p.y, p.x);
    float radius = length(p);
    float pattern = 0;
    
    // Create symmetric divisions
    int divisions = 8;
    angle = mod(angle + PI, 2*PI/divisions) - PI/divisions;
    
    // Generate base pattern
    pattern = sin(angle * divisions) * cos(radius * scale);
    
    // Add detail layers
    pattern += sin(angle * divisions * 2) * cos(radius * scale * 2) * 0.5;
    pattern += noise(p * scale + seed) * 0.3;
    
    return pattern;
}

float generateCelticKnot(vector p, float scale, float seed) {
    float pattern = 0;
    
    // Create interwoven lines
    pattern = sin(p.x * scale) * cos(p.y * scale);
    pattern *= sin((p.x + p.y) * scale * 0.5) * cos((p.x - p.y) * scale * 0.5);
    
    // Add noise for variation
    pattern += noise(p * scale * 2 + seed) * 0.2;
    
    return pattern;
}

float generateMandala(vector p, float scale, float seed) {
    float angle = atan2(p.y, p.x);
    float radius = length(p);
    float pattern = 0;
    
    // Create radial symmetry
    int petals = 12;
    pattern = sin(angle * petals) * sin(radius * scale);
    
    // Add concentric circles
    pattern *= sin(radius * scale * 4);
    
    // Add detail with noise
    pattern += turbulence(p * scale + seed, 3, 0.5, 0.5) * 0.3;
    
    return pattern;
}

// Select and generate pattern based on type
float pattern = 0;
int pattern_type = chi("pattern_type");

if(pattern_type == 0) {
    // Islamic geometric pattern
    pattern = generateIslamicPattern(pos, chf("scale"), seed);
}
else if(pattern_type == 1) {
    // Celtic knot pattern
    pattern = generateCelticKnot(pos, chf("scale"), seed);
}
else if(pattern_type == 2) {
    // Mandala pattern
    pattern = generateMandala(pos, chf("scale"), seed);
}

// Apply complexity and variation
pattern *= chf("complexity");
pattern += noise(pos * chf("variation") + seed) * 0.5;

// Displace points based on pattern
@P += @N * pattern * chf("displacement");

// Generate color based on pattern
vector base_color = chv("base_color");
vector accent_color = chv("accent_color");
float color_mix = fit(pattern, -1, 1, 0, 1);
@Cd = mix(base_color, accent_color, color_mix);

// Add edge highlighting
float edge = 1.0 - abs(dot(@N, normalize(@P)));
@Cd += edge * 0.2;

// Store pattern value for later use
f@pattern = pattern;

// Optional: Add metallic sheen
if(ch("enable_metallic") > 0) {
    float metallic = noise(pos * chf("metallic_scale") + seed);
    @Cd *= 1.0 + metallic * chf("metallic_amount");
}

// Store additional attributes for material
f@roughness = fit(abs(pattern), 0, 1, 0.2, 0.8);
f@metallic = ch("enable_metallic") > 0 ? 0.8 : 0.0; 