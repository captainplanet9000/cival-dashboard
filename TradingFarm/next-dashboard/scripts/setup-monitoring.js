/**
 * Trading Farm Production Monitoring Setup Script
 * 
 * This script sets up monitoring tools for the production environment:
 * 1. Sentry.io for error tracking
 * 2. Uptime checks for critical endpoints
 * 3. Performance monitoring using Web Vitals
 * 4. Database health monitoring
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Configuration
const CONFIG = {
  sentryDSN: process.env.NEXT_PUBLIC_SENTRY_DSN || '',
  appUrl: process.env.NEXT_PUBLIC_APP_URL || 'https://tradingfarm.com',
  apiUrl: process.env.NEXT_PUBLIC_API_BASE_URL || 'https://api.tradingfarm.com/v1',
  environment: process.env.NODE_ENV || 'production',
  alertEmails: (process.env.ALERT_EMAILS || '').split(','),
  redisUrl: process.env.REDIS_URL || '',
  supabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL || '',
  supabaseKey: process.env.SUPABASE_SERVICE_ROLE_KEY || ''
};

console.log('==== Trading Farm Monitoring Setup ====');
console.log(`Environment: ${CONFIG.environment}`);

// Check configuration
if (!CONFIG.sentryDSN) {
  console.warn('⚠️ Warning: Sentry DSN not configured. Error tracking will not be functional.');
}

if (!CONFIG.supabaseUrl || !CONFIG.supabaseKey) {
  console.warn('⚠️ Warning: Supabase credentials not configured. Database monitoring will not be functional.');
}

// Install monitoring dependencies if needed
console.log('\n📦 Installing monitoring dependencies...');
try {
  execSync('npm install @sentry/nextjs @sentry/node @upstash/redis prometheus-client node-cron --save --legacy-peer-deps', { stdio: 'inherit' });
  console.log('✅ Monitoring dependencies installed.');
} catch (error) {
  console.error('❌ Failed to install monitoring dependencies:', error.message);
  process.exit(1);
}

// Create Sentry config
console.log('\n🔧 Configuring Sentry...');
try {
  const sentryConfigContent = `
// This file is generated by setup-monitoring.js
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: "${CONFIG.sentryDSN}",
  environment: "${CONFIG.environment}",
  tracesSampleRate: 0.2,
  profilesSampleRate: 0.1,
  replaysSessionSampleRate: 0.1,
  replaysOnErrorSampleRate: 1.0,
  integrations: [
    new Sentry.Integrations.Http({ tracing: true }),
    new Sentry.Integrations.Prisma({ tracing: true }),
  ],
});
`;

  // Create client-side config
  fs.writeFileSync(
    path.join(process.cwd(), 'sentry.client.config.js'), 
    sentryConfigContent,
    'utf8'
  );
  
  // Create server-side config
  fs.writeFileSync(
    path.join(process.cwd(), 'sentry.server.config.js'), 
    sentryConfigContent,
    'utf8'
  );
  
  // Create edge config
  fs.writeFileSync(
    path.join(process.cwd(), 'sentry.edge.config.js'), 
    sentryConfigContent,
    'utf8'
  );
  
  console.log('✅ Sentry configuration created.');
} catch (error) {
  console.error('❌ Failed to create Sentry configuration:', error.message);
}

// Create monitoring service
console.log('\n🔍 Creating monitoring service...');
try {
  const monitoringServiceContent = `
import { createClient } from '@supabase/supabase-js';
import type { Redis } from '@upstash/redis';
import { Client, Counter, Registry } from 'prometheus-client';
import cron from 'node-cron';

// Monitoring metrics
const registry = new Registry();
const apiCallCounter = new Counter({
  name: 'trading_farm_api_calls_total',
  help: 'Total number of API calls',
  labelNames: ['endpoint', 'status']
});
const exchangeCallCounter = new Counter({
  name: 'trading_farm_exchange_calls_total',
  help: 'Total number of exchange API calls',
  labelNames: ['exchange', 'status']
});
const tradingOperationCounter = new Counter({
  name: 'trading_farm_trading_operations_total',
  help: 'Total number of trading operations',
  labelNames: ['operation', 'status']
});
const errorCounter = new Counter({
  name: 'trading_farm_errors_total',
  help: 'Total number of errors',
  labelNames: ['type', 'component']
});

registry.registerMetric(apiCallCounter);
registry.registerMetric(exchangeCallCounter);
registry.registerMetric(tradingOperationCounter);
registry.registerMetric(errorCounter);

export class MonitoringService {
  private supabase;
  private redis: Redis | null = null;
  private static instance: MonitoringService;
  
  private constructor() {
    // Initialize Supabase client
    this.supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL || '',
      process.env.SUPABASE_SERVICE_ROLE_KEY || ''
    );
    
    // Initialize Redis client if URL is provided
    if (process.env.REDIS_URL) {
      import('@upstash/redis').then(({ Redis }) => {
        this.redis = new Redis({
          url: process.env.REDIS_URL || '',
          token: process.env.REDIS_TOKEN || '',
        });
      }).catch(err => {
        console.error('Failed to initialize Redis:', err);
      });
    }
    
    // Schedule health checks
    this.scheduleHealthChecks();
  }
  
  public static getInstance(): MonitoringService {
    if (!MonitoringService.instance) {
      MonitoringService.instance = new MonitoringService();
    }
    return MonitoringService.instance;
  }
  
  /**
   * Track API call
   */
  public trackApiCall(endpoint: string, status: number): void {
    apiCallCounter.inc({ endpoint, status: status.toString() });
    
    // Log to Supabase for long-term storage
    this.logEvent('api_call', {
      endpoint,
      status,
      timestamp: new Date().toISOString()
    }).catch(err => console.error('Failed to log API call:', err));
  }
  
  /**
   * Track exchange API call
   */
  public trackExchangeCall(exchange: string, status: number): void {
    exchangeCallCounter.inc({ exchange, status: status.toString() });
    
    // Log to Supabase for long-term storage
    this.logEvent('exchange_call', {
      exchange,
      status,
      timestamp: new Date().toISOString()
    }).catch(err => console.error('Failed to log exchange call:', err));
  }
  
  /**
   * Track trading operation
   */
  public trackTradingOperation(operation: string, status: string): void {
    tradingOperationCounter.inc({ operation, status });
    
    // Log to Supabase for long-term storage
    this.logEvent('trading_operation', {
      operation,
      status,
      timestamp: new Date().toISOString()
    }).catch(err => console.error('Failed to log trading operation:', err));
  }
  
  /**
   * Track error
   */
  public trackError(type: string, component: string, error: Error): void {
    errorCounter.inc({ type, component });
    
    // Log to Supabase for long-term storage
    this.logEvent('error', {
      type,
      component,
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    }).catch(err => console.error('Failed to log error:', err));
  }
  
  /**
   * Log event to Supabase
   */
  private async logEvent(eventType: string, data: any): Promise<void> {
    try {
      const { error } = await this.supabase
        .from('monitoring_events')
        .insert([{
          event_type: eventType,
          data
        }]);
      
      if (error) {
        throw error;
      }
    } catch (err) {
      console.error('Failed to log event to Supabase:', err);
      // Fallback to Redis if available
      if (this.redis) {
        const key = \`monitoring:\${eventType}:\${Date.now()}\`;
        await this.redis.set(key, JSON.stringify(data));
        await this.redis.expire(key, 60 * 60 * 24 * 7); // 7 days TTL
      }
    }
  }
  
  /**
   * Check database health
   */
  private async checkDatabaseHealth(): Promise<boolean> {
    try {
      const startTime = Date.now();
      const { data, error } = await this.supabase.from('health_check').select('*').limit(1);
      const responseTime = Date.now() - startTime;
      
      if (error) {
        this.trackError('database', 'health_check', new Error(error.message));
        return false;
      }
      
      // Log response time to Redis for performance tracking
      if (this.redis) {
        await this.redis.lpush('db_response_times', responseTime);
        await this.redis.ltrim('db_response_times', 0, 999); // Keep last 1000 measurements
      }
      
      return true;
    } catch (err) {
      this.trackError('database', 'health_check', err instanceof Error ? err : new Error(String(err)));
      return false;
    }
  }
  
  /**
   * Schedule periodic health checks
   */
  private scheduleHealthChecks(): void {
    // Check database health every 5 minutes
    cron.schedule('*/5 * * * *', async () => {
      const isHealthy = await this.checkDatabaseHealth();
      console.log(\`Database health check: \${isHealthy ? 'HEALTHY' : 'UNHEALTHY'}\`);
      
      if (!isHealthy) {
        // Alert on database health issues
        this.triggerAlert('Database health check failed', 'HIGH');
      }
    });
    
    // Check Redis health if available
    if (this.redis) {
      cron.schedule('*/10 * * * *', async () => {
        try {
          const startTime = Date.now();
          await this.redis?.ping();
          const responseTime = Date.now() - startTime;
          
          // Log response time
          await this.redis?.lpush('redis_response_times', responseTime);
          await this.redis?.ltrim('redis_response_times', 0, 999);
          
          console.log('Redis health check: HEALTHY');
        } catch (err) {
          console.log('Redis health check: UNHEALTHY');
          this.trackError('redis', 'health_check', err instanceof Error ? err : new Error(String(err)));
          this.triggerAlert('Redis health check failed', 'HIGH');
        }
      });
    }
  }
  
  /**
   * Trigger alert for critical issues
   */
  private async triggerAlert(message: string, severity: 'LOW' | 'MEDIUM' | 'HIGH'): Promise<void> {
    try {
      // Log alert to database
      const { error } = await this.supabase
        .from('system_alerts')
        .insert([{
          message,
          severity,
          resolved: false,
          timestamp: new Date().toISOString()
        }]);
      
      if (error) {
        console.error('Failed to log alert:', error);
      }
      
      // Additional alert channels can be integrated here (email, SMS, etc.)
    } catch (err) {
      console.error('Failed to trigger alert:', err);
    }
  }
  
  /**
   * Get metrics in Prometheus format
   */
  public getMetrics(): string {
    return registry.metrics();
  }
}

export default MonitoringService.getInstance();
`;

  // Create monitoring service file
  fs.mkdirSync(path.join(process.cwd(), 'src', 'services'), { recursive: true });
  fs.writeFileSync(
    path.join(process.cwd(), 'src', 'services', 'monitoring.ts'), 
    monitoringServiceContent,
    'utf8'
  );
  
  console.log('✅ Monitoring service created.');
} catch (error) {
  console.error('❌ Failed to create monitoring service:', error.message);
}

// Create monitoring API endpoint
console.log('\n📡 Creating monitoring API endpoint...');
try {
  const monitoringApiContent = `
import { NextRequest, NextResponse } from 'next/server';
import MonitoringService from '@/services/monitoring';

export const runtime = 'edge';

// This endpoint requires authentication in production - only authorized users can access it
export async function GET(req: NextRequest) {
  // Check authorization
  const authHeader = req.headers.get('authorization');
  
  if (process.env.NODE_ENV === 'production') {
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return new NextResponse('Unauthorized', { status: 401 });
    }
    
    const token = authHeader.split(' ')[1];
    
    if (token !== process.env.MONITORING_API_TOKEN) {
      return new NextResponse('Unauthorized', { status: 401 });
    }
  }
  
  // Return metrics in Prometheus format
  return new NextResponse(MonitoringService.getMetrics(), {
    headers: {
      'Content-Type': 'text/plain'
    }
  });
}
`;

  // Create API endpoint directory
  fs.mkdirSync(path.join(process.cwd(), 'src', 'app', 'api', 'monitoring'), { recursive: true });
  fs.writeFileSync(
    path.join(process.cwd(), 'src', 'app', 'api', 'monitoring', 'route.ts'), 
    monitoringApiContent,
    'utf8'
  );
  
  console.log('✅ Monitoring API endpoint created.');
} catch (error) {
  console.error('❌ Failed to create monitoring API endpoint:', error.message);
}

// Create database migration for monitoring tables
console.log('\n🗄️ Creating database migration for monitoring tables...');
try {
  const timestamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0];
  const migrationContent = `-- Migration: Add monitoring tables
-- Created at: ${new Date().toISOString()}

-- Create monitoring_events table to store events for analysis
CREATE TABLE IF NOT EXISTS public.monitoring_events (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  event_type TEXT NOT NULL,
  data JSONB NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  user_id UUID REFERENCES auth.users(id)
);

-- Add index for event_type to speed up queries
CREATE INDEX IF NOT EXISTS idx_monitoring_events_event_type ON public.monitoring_events(event_type);

-- Add index for created_at to speed up time-based queries
CREATE INDEX IF NOT EXISTS idx_monitoring_events_created_at ON public.monitoring_events(created_at);

-- Add RLS policies
ALTER TABLE public.monitoring_events ENABLE ROW LEVEL SECURITY;

-- Only allow admins to view monitoring events
CREATE POLICY "Allow admins to view monitoring events" 
  ON public.monitoring_events
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_roles.user_id = auth.uid()
      AND user_roles.role = 'admin'
    )
  );

-- System can insert monitoring events
CREATE POLICY "System can insert monitoring events" 
  ON public.monitoring_events
  FOR INSERT
  WITH CHECK (true);

-- Create health_check table for database health checks
CREATE TABLE IF NOT EXISTS public.health_check (
  id SERIAL PRIMARY KEY,
  status TEXT NOT NULL DEFAULT 'ok',
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Insert initial record
INSERT INTO public.health_check (status) VALUES ('ok') ON CONFLICT DO NOTHING;

-- Create system_alerts table for critical system alerts
CREATE TABLE IF NOT EXISTS public.system_alerts (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  message TEXT NOT NULL,
  severity TEXT NOT NULL CHECK (severity IN ('LOW', 'MEDIUM', 'HIGH')),
  resolved BOOLEAN NOT NULL DEFAULT false,
  timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  resolved_at TIMESTAMPTZ,
  resolved_by UUID REFERENCES auth.users(id),
  resolution_notes TEXT
);

-- Add index for unresolved alerts
CREATE INDEX IF NOT EXISTS idx_system_alerts_unresolved ON public.system_alerts(resolved) WHERE NOT resolved;

-- Add RLS policies
ALTER TABLE public.system_alerts ENABLE ROW LEVEL SECURITY;

-- Admins can view all alerts
CREATE POLICY "Allow admins to view system alerts" 
  ON public.system_alerts
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_roles.user_id = auth.uid()
      AND user_roles.role = 'admin'
    )
  );

-- System can insert alerts
CREATE POLICY "System can insert alerts" 
  ON public.system_alerts
  FOR INSERT
  WITH CHECK (true);

-- Admins can update alerts (to resolve them)
CREATE POLICY "Allow admins to update system alerts" 
  ON public.system_alerts
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_roles.user_id = auth.uid()
      AND user_roles.role = 'admin'
    )
  );

-- Create performance_metrics table to store performance data
CREATE TABLE IF NOT EXISTS public.performance_metrics (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  metric_type TEXT NOT NULL,
  value NUMERIC NOT NULL,
  dimensions JSONB,
  timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add TimescaleDB hypertable for time-series data if extension exists
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM pg_extension WHERE extname = 'timescaledb'
  ) THEN
    PERFORM create_hypertable('public.performance_metrics', 'timestamp', if_not_exists => TRUE);
  END IF;
END $$;

-- Add index for metric_type
CREATE INDEX IF NOT EXISTS idx_performance_metrics_type ON public.performance_metrics(metric_type);

-- Add RLS policies
ALTER TABLE public.performance_metrics ENABLE ROW LEVEL SECURITY;

-- Allow system to insert metrics
CREATE POLICY "System can insert performance metrics" 
  ON public.performance_metrics
  FOR INSERT
  WITH CHECK (true);

-- Allow admins to view metrics
CREATE POLICY "Allow admins to view performance metrics" 
  ON public.performance_metrics
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.user_roles
      WHERE user_roles.user_id = auth.uid()
      AND user_roles.role = 'admin'
    )
  );

-- Create function to log performance metrics
CREATE OR REPLACE FUNCTION public.log_performance_metric(
  p_metric_type TEXT,
  p_value NUMERIC,
  p_dimensions JSONB DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_id UUID;
BEGIN
  INSERT INTO public.performance_metrics (metric_type, value, dimensions)
  VALUES (p_metric_type, p_value, p_dimensions)
  RETURNING id INTO v_id;
  
  RETURN v_id;
END;
$$;

-- Create function to check system health
CREATE OR REPLACE FUNCTION public.check_system_health()
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_result JSONB;
  v_start_time TIMESTAMPTZ;
  v_duration_ms INT;
  v_db_size BIGINT;
  v_table_count INT;
  v_active_connections INT;
BEGIN
  v_start_time := clock_timestamp();
  
  -- Get database size
  SELECT pg_database_size(current_database()) INTO v_db_size;
  
  -- Get table count
  SELECT count(*) INTO v_table_count 
  FROM information_schema.tables 
  WHERE table_schema = 'public';
  
  -- Get active connections
  SELECT count(*) INTO v_active_connections 
  FROM pg_stat_activity 
  WHERE datname = current_database();
  
  v_duration_ms := extract(milliseconds from clock_timestamp() - v_start_time)::INT;
  
  -- Build result
  v_result := jsonb_build_object(
    'status', 'healthy',
    'timestamp', now(),
    'database_size_bytes', v_db_size,
    'table_count', v_table_count,
    'active_connections', v_active_connections,
    'check_duration_ms', v_duration_ms
  );
  
  -- Update health check table
  UPDATE public.health_check 
  SET updated_at = now(), 
      status = 'ok' 
  WHERE id = 1;
  
  RETURN v_result;
EXCEPTION WHEN OTHERS THEN
  v_result := jsonb_build_object(
    'status', 'unhealthy',
    'timestamp', now(),
    'error', SQLERRM
  );
  
  -- Update health check table
  UPDATE public.health_check 
  SET updated_at = now(), 
      status = 'error: ' || SQLERRM 
  WHERE id = 1;
  
  RETURN v_result;
END;
$$;

-- Create cron job for regular system health checks if extension exists
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM pg_extension WHERE extname = 'pg_cron'
  ) THEN
    SELECT cron.schedule('*/30 * * * *', 'SELECT public.check_system_health()');
  END IF;
END $$;
`;

  // Create migration file
  const migrationDir = path.join(process.cwd(), 'supabase', 'migrations');
  fs.mkdirSync(migrationDir, { recursive: true });
  fs.writeFileSync(
    path.join(migrationDir, `${timestamp}_add_monitoring_tables.sql`), 
    migrationContent,
    'utf8'
  );
  
  console.log('✅ Monitoring database migration created.');
} catch (error) {
  console.error('❌ Failed to create monitoring database migration:', error.message);
}

console.log('\n🎉 Monitoring setup completed!');
console.log('Run the database migration to create monitoring tables.');
console.log('====================================================');
