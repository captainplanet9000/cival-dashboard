/**
 * Security vulnerability scanner
 * Helps identify common security issues in the application
 */

import { getApiCredentials } from './encryption';

interface VulnerabilityResult {
  level: 'critical' | 'high' | 'medium' | 'low' | 'info';
  title: string;
  description: string;
  location?: string;
  recommendation: string;
}

interface ScanOptions {
  /** Whether to scan for local storage vulnerabilities */
  checkLocalStorage?: boolean;
  /** Whether to scan for insecure API endpoints */
  checkApiEndpoints?: boolean;
  /** Whether to scan for DOM-based XSS */
  checkDomXss?: boolean;
  /** Whether to scan for insecure dependencies */
  checkDependencies?: boolean;
  /** Whether to scan for missing CSP */
  checkCsp?: boolean;
  /** Custom scan functions */
  customScans?: Array<() => Promise<VulnerabilityResult[]>>;
}

/**
 * Scan the application for common security vulnerabilities
 * @param options Scan options
 * @returns List of identified vulnerabilities
 */
export async function scanForVulnerabilities(
  options: ScanOptions = {}
): Promise<VulnerabilityResult[]> {
  const {
    checkLocalStorage = true,
    checkApiEndpoints = true,
    checkDomXss = true,
    checkCsp = true,
    checkDependencies = false, // Disabled by default as it requires additional setup
    customScans = [],
  } = options;
  
  const results: VulnerabilityResult[] = [];
  
  // Run selected scans
  if (checkLocalStorage) {
    results.push(...scanLocalStorage());
  }
  
  if (checkApiEndpoints) {
    results.push(...await scanApiEndpoints());
  }
  
  if (checkDomXss) {
    results.push(...scanForDomXss());
  }
  
  if (checkCsp) {
    results.push(...scanForMissingCsp());
  }
  
  if (checkDependencies) {
    results.push(...await scanForVulnerableDependencies());
  }
  
  // Run custom scans
  for (const customScan of customScans) {
    try {
      const customResults = await customScan();
      results.push(...customResults);
    } catch (error) {
      console.error('Error in custom scan:', error);
    }
  }
  
  return results;
}

/**
 * Scan for sensitive data stored in localStorage
 */
function scanLocalStorage(): VulnerabilityResult[] {
  if (typeof window === 'undefined') return [];
  
  const results: VulnerabilityResult[] = [];
  const sensitiveKeywords = [
    'password',
    'secret',
    'token',
    'apikey',
    'api_key',
    'key',
    'credential',
    'auth',
  ];
  
  // Check localStorage for sensitive keys
  Object.keys(localStorage).forEach(key => {
    if (sensitiveKeywords.some(keyword => key.toLowerCase().includes(keyword))) {
      // Check if the key is one of our encrypted API credentials
      if (key.startsWith('trading-farm:') && key.endsWith(':credentials')) {
        // These are expected to be encrypted
        try {
          // Check if it's properly encrypted (should fail without proper password)
          const result = getApiCredentials(
            key.split(':')[1],
            'dummy-password-for-testing'
          );
          
          if (result !== null) {
            // If this succeeds, it wasn't properly encrypted
            results.push({
              level: 'critical',
              title: 'Insufficiently Protected API Credentials',
              description: `The credentials for "${key}" are stored with weak encryption.`,
              location: 'localStorage',
              recommendation: 'Update the encryption mechanism for API keys storage.',
            });
          }
        } catch (e) {
          // Expected to fail - proper encryption in place
        }
      } else {
        // Other sensitive data that should not be in localStorage
        results.push({
          level: 'high',
          title: 'Sensitive Data in Local Storage',
          description: `Potentially sensitive data found in localStorage key: "${key}"`,
          location: 'localStorage',
          recommendation: 'Remove sensitive data from localStorage or use secure storage mechanisms.',
        });
      }
    }
  });
  
  return results;
}

/**
 * Scan for insecure API endpoints
 */
async function scanApiEndpoints(): Promise<VulnerabilityResult[]> {
  if (typeof window === 'undefined') return [];
  
  const results: VulnerabilityResult[] = [];
  
  // Check if the page has non-HTTPS API endpoints
  const scripts = document.querySelectorAll('script');
  let apiEndpoints: string[] = [];
  
  // Extract fetch or axios calls from inline scripts
  scripts.forEach(script => {
    if (!script.src && script.textContent) {
      const content = script.textContent;
      
      // Look for fetch calls with http://
      const fetchMatches = content.match(/fetch\s*\(\s*['"]http:\/\/[^'"]+['"]/g);
      if (fetchMatches) {
        fetchMatches.forEach(match => {
          const url = match.match(/['"]http:\/\/[^'"]+['"]/)?.[0].replace(/['"]/g, '');
          if (url) apiEndpoints.push(url);
        });
      }
      
      // Look for axios calls with http://
      const axiosMatches = content.match(/axios\s*\.\s*(get|post|put|delete)\s*\(\s*['"]http:\/\/[^'"]+['"]/g);
      if (axiosMatches) {
        axiosMatches.forEach(match => {
          const url = match.match(/['"]http:\/\/[^'"]+['"]/)?.[0].replace(/['"]/g, '');
          if (url) apiEndpoints.push(url);
        });
      }
    }
  });
  
  // Check if any API endpoints are using HTTP instead of HTTPS
  apiEndpoints.forEach(endpoint => {
    if (endpoint.startsWith('http://')) {
      results.push({
        level: 'high',
        title: 'Insecure API Endpoint',
        description: `API endpoint using insecure HTTP: ${endpoint}`,
        location: 'API requests',
        recommendation: 'Update all API endpoints to use HTTPS.',
      });
    }
  });
  
  return results;
}

/**
 * Scan for potential DOM-based XSS vulnerabilities
 */
function scanForDomXss(): VulnerabilityResult[] {
  if (typeof window === 'undefined') return [];
  
  const results: VulnerabilityResult[] = [];
  
  // Check for potentially dangerous DOM manipulation patterns
  const scripts = document.querySelectorAll('script');
  
  scripts.forEach(script => {
    if (!script.src && script.textContent) {
      const content = script.textContent;
      
      // Check for innerHTML assignments with concatenated user input (common XSS vector)
      const innerHtmlAssignments = content.match(/\.innerHTML\s*=\s*.+/g);
      if (innerHtmlAssignments) {
        // Check if any assignments use variables or template literals that could contain user input
        const unsafeAssignments = innerHtmlAssignments.filter(assignment => 
          assignment.includes('${') || 
          /\.innerHTML\s*=\s*.+\+/.test(assignment) || 
          /\.innerHTML\s*=\s*[a-zA-Z_$][a-zA-Z0-9_$]*/.test(assignment)
        );
        
        if (unsafeAssignments.length > 0) {
          results.push({
            level: 'high',
            title: 'Potential DOM-based XSS',
            description: 'innerHTML is being assigned potentially unvalidated content, which may lead to XSS vulnerabilities.',
            location: 'JavaScript',
            recommendation: 'Use textContent instead of innerHTML, or sanitize content before assigning to innerHTML.',
          });
        }
      }
      
      // Check for document.write usage (another XSS vector)
      if (content.includes('document.write')) {
        results.push({
          level: 'medium',
          title: 'Unsafe document.write Usage',
          description: 'document.write is being used, which can introduce XSS vulnerabilities if used with untrusted input.',
          location: 'JavaScript',
          recommendation: 'Avoid using document.write. Use safer DOM manipulation methods instead.',
        });
      }
    }
  });
  
  return results;
}

/**
 * Scan for missing Content Security Policy
 */
function scanForMissingCsp(): VulnerabilityResult[] {
  if (typeof window === 'undefined') return [];
  
  const results: VulnerabilityResult[] = [];
  
  // Check if CSP is present in meta tags or headers
  const cspMetaTag = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
  
  if (!cspMetaTag) {
    // Check if it might be defined in HTTP headers instead
    const hasHeaderCsp = typeof window.__CSP_NONCE__ !== 'undefined';
    
    if (!hasHeaderCsp) {
      results.push({
        level: 'medium',
        title: 'Missing Content Security Policy',
        description: 'No Content Security Policy (CSP) was detected for this page.',
        location: 'HTML/HTTP Headers',
        recommendation: 'Implement a strong Content Security Policy to mitigate XSS and other injection attacks.',
      });
    }
  }
  
  return results;
}

/**
 * Scan for vulnerable dependencies
 * Note: This is a simplified version and would normally integrate with tools like npm audit
 */
async function scanForVulnerableDependencies(): Promise<VulnerabilityResult[]> {
  const results: VulnerabilityResult[] = [];
  
  // In a real implementation, this would make API calls to vulnerability databases
  // or integrate with tools like npm audit
  
  // Simulated detection of vulnerable packages
  results.push({
    level: 'info',
    title: 'Dependency Vulnerability Scan',
    description: 'To perform a comprehensive dependency vulnerability scan, run `npm audit` from the command line.',
    recommendation: 'Regularly run dependency vulnerability scans and keep dependencies updated.',
  });
  
  return results;
}

/**
 * Generate a security report based on scan results
 * @param vulnerabilities List of identified vulnerabilities
 * @returns HTML report
 */
export function generateSecurityReport(vulnerabilities: VulnerabilityResult[]): string {
  // Count vulnerabilities by severity
  const counts = {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0,
    info: 0,
  };
  
  vulnerabilities.forEach(vuln => {
    counts[vuln.level]++;
  });
  
  // Generate report HTML
  let report = `
    <div class="security-report">
      <h2>Security Vulnerability Report</h2>
      <p>Generated on: ${new Date().toISOString()}</p>
      
      <div class="summary">
        <h3>Summary</h3>
        <div class="severity-counts">
          <div class="severity critical">Critical: ${counts.critical}</div>
          <div class="severity high">High: ${counts.high}</div>
          <div class="severity medium">Medium: ${counts.medium}</div>
          <div class="severity low">Low: ${counts.low}</div>
          <div class="severity info">Info: ${counts.info}</div>
        </div>
      </div>
      
      <div class="vulnerabilities">
        <h3>Detected Issues</h3>
        ${vulnerabilities.length === 0 ? '<p>No vulnerabilities detected.</p>' : ''}
  `;
  
  // Add each vulnerability to the report
  vulnerabilities.forEach(vuln => {
    report += `
      <div class="vulnerability ${vuln.level}">
        <h4>${vuln.title}</h4>
        <p><strong>Severity:</strong> ${vuln.level}</p>
        ${vuln.location ? `<p><strong>Location:</strong> ${vuln.location}</p>` : ''}
        <p><strong>Description:</strong> ${vuln.description}</p>
        <p><strong>Recommendation:</strong> ${vuln.recommendation}</p>
      </div>
    `;
  });
  
  report += `
      </div>
    </div>
    <style>
      .security-report { font-family: sans-serif; max-width: 800px; margin: 0 auto; }
      .severity-counts { display: flex; gap: 10px; margin-bottom: 20px; }
      .severity { padding: 5px 10px; border-radius: 4px; }
      .critical { background: #ffdddd; color: #d32f2f; border: 1px solid #d32f2f; }
      .high { background: #fff0dd; color: #e65100; border: 1px solid #e65100; }
      .medium { background: #fffbdd; color: #f57f17; border: 1px solid #f57f17; }
      .low { background: #e1f5fe; color: #0277bd; border: 1px solid #0277bd; }
      .info { background: #e8f5e9; color: #2e7d32; border: 1px solid #2e7d32; }
      .vulnerability { padding: 10px; margin-bottom: 15px; border-radius: 4px; border-left: 4px solid; }
      .vulnerability.critical { border-left-color: #d32f2f; background: #ffebee; }
      .vulnerability.high { border-left-color: #e65100; background: #fff3e0; }
      .vulnerability.medium { border-left-color: #f57f17; background: #fffde7; }
      .vulnerability.low { border-left-color: #0277bd; background: #e1f5fe; }
      .vulnerability.info { border-left-color: #2e7d32; background: #e8f5e9; }
    </style>
  `;
  
  return report;
}
