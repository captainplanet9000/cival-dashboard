-- Migration to create exchange connections table and related functions

-- Create exchange_connections table
CREATE TABLE IF NOT EXISTS public.exchange_connections (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  exchange TEXT NOT NULL CHECK (exchange IN ('bybit', 'coinbase', 'hyperliquid')),
  is_testnet BOOLEAN DEFAULT false NOT NULL,
  credentials JSONB NOT NULL,
  is_default BOOLEAN DEFAULT false NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL
);

-- Create RPC function to create the table (used by the factory)
CREATE OR REPLACE FUNCTION public.create_exchange_connections_table()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- Table is created in the migration, so this function is just a no-op placeholder
  -- that can be called safely even when the table exists
  RETURN;
END;
$$;

-- Create updated_at trigger
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.exchange_connections
  FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

-- Apply Row Level Security (RLS)
ALTER TABLE public.exchange_connections ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY "Users can view their own exchange connections"
  ON public.exchange_connections
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own exchange connections"
  ON public.exchange_connections
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own exchange connections"
  ON public.exchange_connections
  FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own exchange connections"
  ON public.exchange_connections
  FOR DELETE
  USING (auth.uid() = user_id);

-- Create function to validate exchange credentials
CREATE OR REPLACE FUNCTION public.validate_exchange_credentials()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- Validate Bybit credentials
  IF NEW.exchange = 'bybit' THEN
    IF NOT (NEW.credentials ? 'apiKey' AND NEW.credentials ? 'apiSecret') THEN
      RAISE EXCEPTION 'Bybit credentials must include apiKey and apiSecret';
    END IF;
  -- Validate Coinbase credentials
  ELSIF NEW.exchange = 'coinbase' THEN
    IF NOT (NEW.credentials ? 'apiKey' AND NEW.credentials ? 'apiSecret' AND NEW.credentials ? 'passphrase') THEN
      RAISE EXCEPTION 'Coinbase credentials must include apiKey, apiSecret, and passphrase';
    END IF;
  -- Validate Hyperliquid credentials
  ELSIF NEW.exchange = 'hyperliquid' THEN
    IF NOT (NEW.credentials ? 'privateKey' AND NEW.credentials ? 'walletAddress') THEN
      RAISE EXCEPTION 'Hyperliquid credentials must include privateKey and walletAddress';
    END IF;
  END IF;
  
  -- All validations passed
  RETURN NEW;
END;
$$;

-- Create trigger for credentials validation
CREATE TRIGGER validate_exchange_credentials
  BEFORE INSERT OR UPDATE ON public.exchange_connections
  FOR EACH ROW
  EXECUTE FUNCTION public.validate_exchange_credentials();

-- Create function to ensure only one default connection per user
CREATE OR REPLACE FUNCTION public.ensure_single_default_connection()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  -- If this connection is being set as default
  IF NEW.is_default = true THEN
    -- Update any other default connections for this user to not be default
    UPDATE public.exchange_connections
    SET is_default = false
    WHERE user_id = NEW.user_id
      AND id != NEW.id
      AND is_default = true;
  END IF;
  
  RETURN NEW;
END;
$$;

-- Create trigger for default connection management
CREATE TRIGGER ensure_single_default_connection
  BEFORE INSERT OR UPDATE ON public.exchange_connections
  FOR EACH ROW
  EXECUTE FUNCTION public.ensure_single_default_connection();

-- Create function to encrypt sensitive credentials
CREATE OR REPLACE FUNCTION public.encrypt_exchange_credentials()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  encrypted_creds JSONB;
  key TEXT;
  value TEXT;
BEGIN
  encrypted_creds = '{}';
  
  -- Iterate through credentials and encrypt sensitive fields
  FOR key, value IN SELECT * FROM jsonb_each_text(NEW.credentials)
  LOOP
    IF key IN ('apiSecret', 'privateKey', 'passphrase') THEN
      -- Use pgcrypto to encrypt sensitive values
      -- In a production environment, use a proper encryption key management system
      encrypted_creds = jsonb_set(
        encrypted_creds,
        ARRAY[key],
        to_jsonb(encode(
          pgp_sym_encrypt(
            value,
            current_setting('app.settings.encryption_key', true)
          )::bytea,
          'base64'
        ))
      );
    ELSE
      -- Keep non-sensitive data as is
      encrypted_creds = jsonb_set(encrypted_creds, ARRAY[key], to_jsonb(value));
    END IF;
  END LOOP;
  
  NEW.credentials = encrypted_creds;
  RETURN NEW;
END;
$$;

-- Comment out the trigger for now since we haven't set up encryption key
-- In a production environment, uncomment this and set up proper encryption
-- CREATE TRIGGER encrypt_exchange_credentials
--   BEFORE INSERT OR UPDATE ON public.exchange_connections
--   FOR EACH ROW
--   EXECUTE FUNCTION public.encrypt_exchange_credentials();
