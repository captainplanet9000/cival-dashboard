from fastapi import FastAPI, BackgroundTasks, HTTPException, Query
from supabase import create_client as create_supabase_client
import os
from typing import Optional # Added Optional for response_model
from dotenv import load_dotenv
import uuid # For task_id if not generated by AgentTask model
import json # For parsing crew results, serializing arguments in ToolCallArgs
from datetime import datetime, timezone 
import uuid # Already imported, but ensure it's used for messageId too

# AG-UI Event Imports
from ag_ui_protocol.events import (
    RunStarted, RunFinished, RunError, 
    StepStarted, StepFinished,
    TextMessageStart, TextMessageContent, TextMessageEnd
)
# Local Imports
from websocket_server import schedule_broadcast # Assuming websocket_server.py is at the root of python-ai-services

# Assuming models, services, agents are importable from current structure
from models.api_models import (
    CrewRunRequest, CrewRunResponse, 
    CreateAgentApiPayload, UpdateAgentApiPayload, TradingAgentDetailsResponse
)
from models.base_models import TradeSignal # For parsing final result
from services.agent_task_service import AgentTaskService
from services.simulated_trade_executor import SimulatedTradeExecutor
from services.agent_service import (
    AgentService, 
    AgentRecordNotFoundError, 
    # AgentForbiddenError, # This error was not defined in agent_service.py, use generic AgentServiceError or define if needed
    AgentConfigValidationError,
    UserFundingWalletError, # Specific error for client
    StrategyNotFoundError,  # Specific error for client
    InsufficientFundsError, # Specific error for client
    AgentRecordCreationError, # Server-side error
    AgentWalletCreationError, # Server-side error
    AgentWalletLinkError,     # Server-side error
    AgentFundingError,        # Server-side error
    AgentActivationError,     # Server-side error
    AgentUpdateError          # Server-side error for updates
)
from services.vault_service import VaultService
from agents.trading_crew import trading_crew # The CrewAI instance
# get_llm might be needed if crew/agents are not pre-initialized with an LLM
from agents.crew_llm_config import get_llm, ERROR_MSG as LLM_ERROR_MSG 
from models.agent_task_models import AgentTask # For type hint
import logging # Added import for logger

# Define a simple logger
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO) # Configure basic logging

# Custom Exception (if not defined elsewhere, this is a placeholder)
class AgentServiceError(Exception):
    pass

load_dotenv()

app = FastAPI(title="Python AI Services API - CrewAI Extension")

# Initialize Supabase client (used by AgentTaskService)
supabase_url = os.environ.get("NEXT_PUBLIC_SUPABASE_URL")
supabase_key = os.environ.get("SUPABASE_SERVICE_ROLE_KEY")

supabase_client = None
agent_task_service = None
simulated_trade_executor = None
vault_service_instance = None # Renamed to avoid conflict if VaultService was also class name
agent_service_instance = None # Renamed

if not supabase_url or not supabase_key:
    print("CRITICAL: Supabase URL or Key not configured for Python service. Services will not be available.")
else:
    try:
        supabase_client = create_supabase_client(supabase_url, supabase_key)
        agent_task_service = AgentTaskService(supabase=supabase_client, logger=logger) # Pass logger
        simulated_trade_executor = SimulatedTradeExecutor(supabase_url, supabase_key)
        
        # Instantiate VaultService and AgentService
        vault_service_instance = VaultService(supabase_client=supabase_client, logger=logger)
        agent_service_instance = AgentService(supabase_client=supabase_client, vault_service=vault_service_instance, logger=logger)
        
        print("Supabase client, AgentTaskService, SimulatedTradeExecutor, VaultService, and AgentService initialized.")
    except Exception as e:
        logger.error(f"CRITICAL: Failed to initialize Supabase client or services: {e}", exc_info=True)
        # Keep other services as None if one fails, or handle more gracefully

# Helper function for emitting thoughts
def _emit_agui_thought(thread_id_for_agui: str, run_id: str, thought_content: str):
    timestamp = datetime.now(timezone.utc).isoformat()
    msg_id = str(uuid.uuid4())
    try:
        # Ensure content is string
        content_str = json.dumps(thought_content, indent=2) if not isinstance(thought_content, str) else thought_content
        
        schedule_broadcast(thread_id_for_agui, TextMessageStart(messageId=msg_id, role="assistant", runId=run_id, threadId=thread_id_for_agui, timestamp=timestamp).model_dump(mode='json'))
        schedule_broadcast(thread_id_for_agui, TextMessageContent(messageId=msg_id, delta=content_str, runId=run_id, threadId=thread_id_for_agui, timestamp=timestamp).model_dump(mode='json'))
        schedule_broadcast(thread_id_for_agui, TextMessageEnd(messageId=msg_id, runId=run_id, threadId=thread_id_for_agui, timestamp=timestamp).model_dump(mode='json'))
    except Exception as e:
        print(f"Error emitting AG-UI thought for run {run_id}: {e}")


def run_crew_background(task_id: uuid.UUID, symbol: str, market_data_summary: str, user_id_str: str):
    run_id = str(task_id) 
    thread_id_for_agui = str(task_id) 
    timestamp_start = datetime.now(timezone.utc).isoformat()
    
    print(f"Background task {run_id} started for symbol: {symbol}")

    if not agent_task_service:
        print(f"AgentTaskService not initialized. Cannot update task {run_id}.")
        # No schedule_broadcast here as it might not be available if this itself is the issue
        return
    
    try:
        schedule_broadcast(thread_id_for_agui, RunStarted(runId=run_id, threadId=thread_id_for_agui, timestamp=timestamp_start).model_dump(mode='json'))
        _emit_agui_thought(thread_id_for_agui, run_id, f"Crew run {run_id} started for symbol '{symbol}'. Inputs provided: market_data_summary='{market_data_summary}'. User ID: {user_id_str}")

        llm_instance = None
        try:
            llm_instance = get_llm()
        except EnvironmentError as e:
            err_msg_llm = f"LLM not available for crew run (task {run_id}): {e}"
            _emit_agui_thought(thread_id_for_agui, run_id, f"Error: {err_msg_llm}")
            raise AgentServiceError(err_msg_llm) # Re-raise to be caught by outer try-except

        if not trading_crew or not llm_instance:
            err_msg_crew_init = "TradingCrew not available or LLM failed to initialize within crew context."
            _emit_agui_thought(thread_id_for_agui, run_id, f"Error: {err_msg_crew_init}")
            raise AgentServiceError(err_msg_crew_init) # Re-raise

        agent_task_service.update_task_status(task_id, "RUNNING")
        
        step_crew_execution = "CrewExecution"
        schedule_broadcast(thread_id_for_agui, StepStarted(runId=run_id, stepName=step_crew_execution, timestamp=datetime.now(timezone.utc).isoformat()).model_dump(mode='json'))
        
        inputs = {'symbol': symbol, 'market_data_summary': market_data_summary}
        _emit_agui_thought(thread_id_for_agui, run_id, f"Kicking off CrewAI with inputs: {inputs}")
        crew_result_raw = trading_crew.kickoff(inputs=inputs)
        _emit_agui_thought(thread_id_for_agui, run_id, f"CrewAI kickoff complete. Raw result: {crew_result_raw}")
        
        schedule_broadcast(thread_id_for_agui, StepFinished(runId=run_id, stepName=step_crew_execution, timestamp=datetime.now(timezone.utc).isoformat()).model_dump(mode='json'))
        
        final_result_data = {"raw_crew_output": str(crew_result_raw)} # Initialize with raw output
        trade_signal_obj: Optional[TradeSignal] = None

        if crew_result_raw:
            step_result_parsing = "ResultParsing"
            schedule_broadcast(thread_id_for_agui, StepStarted(runId=run_id, stepName=step_result_parsing, timestamp=datetime.now(timezone.utc).isoformat()).model_dump(mode='json'))
            try:
                if isinstance(crew_result_raw, dict):
                    parsed_output_dict = crew_result_raw
                elif isinstance(crew_result_raw, str):
                    cleaned_json_string = crew_result_raw.strip()
                    if cleaned_json_string.startswith("```json"): cleaned_json_string = cleaned_json_string[7:]
                    if cleaned_json_string.endswith("```"): cleaned_json_string = cleaned_json_string[:-3]
                    parsed_output_dict = json.loads(cleaned_json_string.strip())
                else:
                    raise ValueError("Unexpected result type from crew. Expected dict or JSON string.")

                if 'timestamp' not in parsed_output_dict:
                    parsed_output_dict['timestamp'] = datetime.now(timezone.utc).isoformat()
                if 'action' in parsed_output_dict and isinstance(parsed_output_dict['action'], str):
                    parsed_output_dict['action'] = parsed_output_dict['action'].upper()

                trade_signal_obj = TradeSignal(**parsed_output_dict)
                # Store the parsed signal, replacing raw_crew_output if parsing is successful
                final_result_data = {"trade_signal": trade_signal_obj.model_dump(mode='json')}
                _emit_agui_thought(thread_id_for_agui, run_id, f"Successfully parsed TradeSignal: {final_result_data['trade_signal']}")
                schedule_broadcast(thread_id_for_agui, StepFinished(runId=run_id, stepName=step_result_parsing, output=final_result_data["trade_signal"], timestamp=datetime.now(timezone.utc).isoformat()).model_dump(mode='json'))
            except Exception as e:
                err_msg_parsing = f"Result parsing error: {e}"
                _emit_agui_thought(thread_id_for_agui, run_id, f"Error parsing crew result. Raw: {crew_result_raw}. Error: {err_msg_parsing}")
                # Keep final_result_data as {"raw_crew_output": ...} in this case
                schedule_broadcast(thread_id_for_agui, StepFinished(runId=run_id, stepName=step_result_parsing, error_message=err_msg_parsing, timestamp=datetime.now(timezone.utc).isoformat()).model_dump(mode='json'))
        else: # crew_result_raw is None or empty
            _emit_agui_thought(thread_id_for_agui, run_id, "Crew finished with no specific output from last task.")
            final_result_data = {"message": "Crew finished with no specific output from last task."}


        # Trade Execution based on parsed TradeSignal
        if trade_signal_obj and trade_signal_obj.action in ["BUY", "SELL"] and simulated_trade_executor:
            _emit_agui_thought(thread_id_for_agui, run_id, f"Trade signal is {trade_signal_obj.action}. Attempting simulated trade...")
            
            task_details_for_trade: Optional[AgentTask] = agent_task_service.get_task(task_id)
            agent_id_for_trade = task_details_for_trade.agent_id if task_details_for_trade else None
            
            if agent_id_for_trade:
                agent_config_resp = supabase_client.table('trading_agents').select('configuration_parameters').eq('agent_id', str(agent_id_for_trade)).single().execute()
                quantity_to_trade = 1.0 # Default
                if agent_config_resp.data and agent_config_resp.data.get('configuration_parameters'):
                    quantity_to_trade = float(agent_config_resp.data['configuration_parameters'].get('quantity', 1.0))
                
                trade_execution_result = simulated_trade_executor.execute_trade(
                    agent_id=str(agent_id_for_trade),
                    user_id=user_id_str, # Use original user_id_str from request
                    symbol=trade_signal_obj.symbol,
                    direction=trade_signal_obj.action,
                    quantity=quantity_to_trade,
                    price=trade_signal_obj.execution_price, # This can be None
                    strategy_id=task_details_for_trade.task_name, # Using task_name as a proxy for strategy context
                    notes=f"Simulated trade by CrewAI task {task_id}. Rationale: {trade_signal_obj.rationale}. Confidence: {trade_signal_obj.confidence}."
                )
                _emit_agui_thought(thread_id_for_agui, run_id, f"Simulated trade execution result: {trade_execution_result}")
                # Ensure trade_signal is part of the final_result_data when trade is attempted
                if "trade_signal" not in final_result_data: # Should not happen if trade_signal_obj exists
                    final_result_data["trade_signal"] = trade_signal_obj.model_dump(mode='json')
                final_result_data["simulated_trade_outcome"] = trade_execution_result
            else:
                _emit_agui_thought(thread_id_for_agui, run_id, "Agent ID for trade not found in task details. Skipping trade execution.")
                # Ensure trade_signal is part of the final_result_data
                if "trade_signal" not in final_result_data and trade_signal_obj:
                     final_result_data["trade_signal"] = trade_signal_obj.model_dump(mode='json')
                final_result_data["simulated_trade_outcome"] = {"status": "skipped", "reason": "Agent ID for trade not found."}
        
        # Update task status to COMPLETED or FAILED based on outcomes
        # Check if trade_signal was successfully parsed
        if "trade_signal" in final_result_data:
            # If trade was attempted, its outcome determines FAILED or COMPLETED
            if "simulated_trade_outcome" in final_result_data:
                if final_result_data["simulated_trade_outcome"].get("status") == "failed":
                    agent_task_service.update_task_status(task_id, "FAILED", results=final_result_data, error_message=final_result_data["simulated_trade_outcome"].get("reason", "Trade execution failed"))
                else: # Trade succeeded or skipped (which is not a failure of the task)
                    agent_task_service.update_task_status(task_id, "COMPLETED", results=final_result_data)
            else: # Trade was not attempted (e.g. action was HOLD), but signal was parsed
                agent_task_service.update_task_status(task_id, "COMPLETED", results=final_result_data)
        elif "raw_crew_output" in final_result_data: # Parsing failed, crew_result_raw is available
            agent_task_service.update_task_status(task_id, "FAILED", results=final_result_data, error_message="Result parsing error, no trade action taken.")
        elif "message" in final_result_data: # Crew had no output
             agent_task_service.update_task_status(task_id, "COMPLETED", results=final_result_data)
        else: # Should not happen, but as a fallback
             agent_task_service.update_task_status(task_id, "FAILED", results={"error": "Unknown state in run_crew_background"}, error_message="Unknown state")

        schedule_broadcast(thread_id_for_agui, RunFinished(runId=run_id, threadId=thread_id_for_agui, timestamp=datetime.now(timezone.utc).isoformat(), result=final_result_data).model_dump(mode='json'))

    except AgentServiceError as ase: # Catch custom error first
        error_message = str(ase)
        logger.error(f"AgentServiceError during crew execution for task {run_id}: {error_message}", exc_info=True)
        if agent_task_service:
            try:
                agent_task_service.update_task_status(task_id, "FAILED", error_message=error_message)
            except Exception as db_error:
                 logger.error(f"CRITICAL: Failed to update task {task_id} to FAILED status after AgentServiceError: {db_error}", exc_info=True)
        schedule_broadcast(thread_id_for_agui, RunError(runId=run_id, threadId=thread_id_for_agui, message=error_message, code="AGENT_SERVICE_ERROR", timestamp=datetime.now(timezone.utc).isoformat()).model_dump(mode='json'))

    except Exception as e:
        error_message = str(e)
        logger.error(f"Error during crew execution for task {run_id}: {error_message}", exc_info=True)
        if agent_task_service:
            try:
                agent_task_service.update_task_status(task_id, "FAILED", error_message=error_message)
            except Exception as db_error:
                 logger.error(f"CRITICAL: Failed to update task {task_id} to FAILED status after main error: {db_error}", exc_info=True)
        schedule_broadcast(thread_id_for_agui, RunError(runId=run_id, threadId=thread_id_for_agui, message=error_message, code="CREW_EXECUTION_ERROR", timestamp=datetime.now(timezone.utc).isoformat()).model_dump(mode='json'))


@app.post("/crew/run_trading_analysis", response_model=CrewRunResponse)
async def trigger_crew_run(crew_request: CrewRunRequest, background_tasks: BackgroundTasks):
    if not supabase_client or not agent_task_service:
        raise HTTPException(status_code=503, detail="Core services (Supabase/AgentTaskService) not available.")
    try:
        get_llm() # This will raise EnvironmentError if LLM is not configured or failed
    except EnvironmentError as e:
        print(f"LLM configuration error: {LLM_ERROR_MSG}") # Print specific message from config
        raise HTTPException(status_code=503, detail=f"LLM not available: {LLM_ERROR_MSG}")

    print(f"Received request to run crew for symbol: {crew_request.symbol}, user: {crew_request.user_id}")
    
    try:
        task_user_id = uuid.UUID(crew_request.user_id)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid user_id format. Must be a valid UUID.")

    new_task = agent_task_service.create_task(
        user_id=task_user_id, 
        task_name=f"Trading Analysis for {crew_request.symbol}",
        input_parameters=crew_request.model_dump()
    )
    
    background_tasks.add_task(
        run_crew_background, 
        new_task.task_id, 
        crew_request.symbol, 
        crew_request.market_data_summary,
        crew_request.user_id # Pass as string, will be converted to UUID in background if needed
    )
    
    return CrewRunResponse(task_id=new_task.task_id, status="PENDING", message="Crew run initiated.")


# Agent CRUD Endpoints
@app.post("/agents", response_model=TradingAgentDetailsResponse)
async def create_new_agent(payload: CreateAgentApiPayload, user_id: str = Query(...)):
    if not agent_service_instance:
        raise HTTPException(status_code=503, detail="AgentService not available.")
    if not user_id: # Should be caught by Query(...) but defensive check
        raise HTTPException(status_code=400, detail="user_id query parameter is required.")
        
    try:
        user_uuid = uuid.UUID(user_id)
        created_agent_dict = agent_service_instance.create_agent(
            payload=payload.model_dump(), 
            user_id=user_uuid
        )
        # Assuming create_agent returns a dict that matches TradingAgentDetailsResponse structure
        # If it returns a Pydantic model, FastAPI will serialize it. If dict, ensure it matches.
        return TradingAgentDetailsResponse(**created_agent_dict)
    except ValueError as ve: # For invalid UUID or other basic validation
        logger.warning(f"Value error in create_agent: {ve}", exc_info=True)
        raise HTTPException(status_code=400, detail=f"Invalid input: {str(ve)}")
    except (AgentConfigValidationError, UserFundingWalletError, StrategyNotFoundError, InsufficientFundsError) as e:
        logger.warning(f"Client-side error in create_agent: {e}", exc_info=True) # Log these as warnings
        if isinstance(e, AgentConfigValidationError):
             raise HTTPException(status_code=400, detail={"message": str(e), "errors": e.validation_errors})
        raise HTTPException(status_code=400, detail=str(e))
    except (AgentRecordCreationError, AgentWalletCreationError, AgentWalletLinkError, AgentFundingError, AgentActivationError) as e:
        logger.error(f"Server-side error in create_agent: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error in create_agent: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {str(e)}")


@app.put("/agents/{agent_id}", response_model=TradingAgentDetailsResponse)
async def update_existing_agent(agent_id: uuid.UUID, payload: UpdateAgentApiPayload, user_id: str = Query(...)):
    if not agent_service_instance:
        raise HTTPException(status_code=503, detail="AgentService not available.")
    if not user_id:
        raise HTTPException(status_code=400, detail="user_id query parameter is required.")

    try:
        user_uuid = uuid.UUID(user_id)
        # Pass exclude_unset=True to only update fields that were actually provided in the payload
        updated_agent_dict = agent_service_instance.update_agent_details(
            agent_id=agent_id, 
            payload=payload.model_dump(exclude_unset=True), 
            user_id=user_uuid
        )
        return TradingAgentDetailsResponse(**updated_agent_dict)
    except ValueError as ve: # Invalid UUID
        logger.warning(f"Value error in update_agent: {ve}", exc_info=True)
        raise HTTPException(status_code=400, detail=f"Invalid input: {str(ve)}")
    except AgentRecordNotFoundError as e:
        logger.warning(f"Agent not found in update_agent: {e}") # Not an error, but a client mistake
        raise HTTPException(status_code=404, detail=str(e))
    # AgentForbiddenError was not defined, using AgentServiceError for now or could be specific if user_id mismatch
    # For user_id mismatch, _get_agent_raw in service returns None, leading to AgentRecordNotFoundError.
    # If RLS handles ownership, direct forbidden errors might not be needed at service layer unless explicitly checked.
    except (AgentConfigValidationError, StrategyNotFoundError) as e: # Specific client errors for update
        logger.warning(f"Client-side error in update_agent: {e}", exc_info=True)
        if isinstance(e, AgentConfigValidationError):
             raise HTTPException(status_code=400, detail={"message": str(e), "errors": e.validation_errors})
        raise HTTPException(status_code=400, detail=str(e))
    except AgentUpdateError as e: # Server-side issue during update
        logger.error(f"Server-side error in update_agent: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error in update_agent: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {str(e)}")


@app.get("/tasks/{task_id}", response_model=Optional[AgentTask])
async def get_agent_task_status(task_id: uuid.UUID, user_id: Optional[str] = Query(None)): # user_id for auth
    if not agent_task_service:
        raise HTTPException(status_code=503, detail="AgentTaskService not available.")
    if not user_id: # Require user_id for authorization
        raise HTTPException(status_code=400, detail="user_id query parameter is required.")

    try:
        # Convert user_id string to UUID for service layer if necessary
        user_uuid = uuid.UUID(user_id)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid user_id format.")

    task = agent_task_service.get_task(task_id=task_id)
    if task:
        # Authorization: Ensure the task belongs to the user making the request
        if task.user_id != user_uuid:
            # For GET, it's more common to return 404 if not found OR not authorized, to avoid leaking existence.
            # However, explicit 403 is also fine if we want to be specific.
            raise HTTPException(status_code=403, detail="User not authorized to access this task or task not found.")
        return task
    else:
        raise HTTPException(status_code=404, detail=f"Task {task_id} not found.")

@app.get("/")
async def root():
    llm_status = "OK"
    if LLM_ERROR_MSG:
        llm_status = f"Error: {LLM_ERROR_MSG}"
    elif not get_llm(): # Should not happen if ERROR_MSG is set correctly
        llm_status = "Not initialized or error during init."

    return {
        "message": "Python AI Services with CrewAI is running.",
        "supabase_client_initialized": supabase_client is not None,
        "agent_task_service_initialized": agent_task_service is not None,
        "llm_status": llm_status
    }

# To run this FastAPI app (example, if user runs it directly):
# Ensure .env file is in python-ai-services directory
# uvicorn main:app --host 0.0.0.0 --port ${PYTHON_API_PORT:-8000} --reload
# The PYTHON_API_PORT can be set in .env or defaults to 8000
    
if __name__ == "__main__":
    import uvicorn
    port = int(os.environ.get("PYTHON_API_PORT", 8000))
    uvicorn.run("main:app", host="0.0.0.0", port=port, reload=True)