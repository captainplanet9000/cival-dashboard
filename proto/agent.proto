syntax = "proto3";

package elizaos.agent;

import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";

// Basic agent identification and specification
message AgentSpec {
  string id = 1; // Unique Agent ID (UUID)
  string type = 2;  // e.g., "manager", "worker", "specialist"
  string farm_id = 3; // Farm context
  map<string, string> capabilities = 4; // Key-value pairs of capabilities (e.g., "skill": "data_analysis")
  int32 max_workers = 5;  // Relevant for managers
  google.protobuf.Struct initial_state = 6; // Optional initial state or config
}

// Represents a task assigned to an agent
message Task {
  string task_id = 1; // Unique Task ID
  string goal_id = 2; // Associated goal ID
  string assigned_agent_id = 3; // Which agent is currently assigned
  string manager_id = 4; // Manager overseeing this task/worker
  string description = 5; // Human-readable description
  google.protobuf.Struct payload = 6; // Task-specific data
  string status = 7; // e.g., "pending", "assigned", "running", "completed", "failed"
  int32 priority = 8; // Task priority
  google.protobuf.Timestamp created_at = 9;
  google.protobuf.Timestamp deadline = 10; // Optional deadline
}

// Represents the result of a task execution
message TaskResult {
    string task_id = 1;
    string agent_id = 2;
    bool success = 3;
    google.protobuf.Struct output = 4; // Output data if successful
    string error_message = 5; // Error message if failed
    google.protobuf.Timestamp completed_at = 6;
}

// Agent heartbeat message
message Heartbeat {
    string agent_id = 1;
    google.protobuf.Timestamp timestamp = 2;
    string status = 3; // Current status ("idle", "working", "initializing", etc.)
    google.protobuf.Struct metrics = 4; // Optional metrics like load, memory usage
}

// Request to execute a specific task
message TaskRequest {
    Task task = 1; // The task to be executed
}

// Request to specialize a worker agent
message SpecializationRequest {
    string worker_id = 1;
    string manager_id = 2; // Manager requesting specialization
    google.protobuf.Struct performance_data = 3; // Recent performance metrics
    string desired_outcome = 4; // What the specialization should achieve
}

// Response after specialization attempt
message SpecializationResponse {
    string worker_id = 1;
    bool success = 2;
    string new_specialization = 3; // Description of the applied specialization
    string message = 4; // e.g., "Specialization applied", "Analysis ongoing"
}

// Response after registering an agent
message RegistrationResponse {
    string agent_id = 1;
    bool success = 2;
    string message = 3;
    google.protobuf.Struct initial_config = 4; // Any config sent back from ElizaOS
}

// Main message wrapper for bidirectional streaming
message AgentMessage {
  string message_id = 1; // Unique ID for this message
  string agent_id = 2;   // ID of the agent sending/receiving
  google.protobuf.Timestamp timestamp = 3;

  oneof content {
    Heartbeat heartbeat = 4;
    TaskRequest task_request = 5;       // Sent to Agent: Execute this task
    TaskResult task_result = 6;         // Sent from Agent: Task execution outcome
    // Add other message types as needed, e.g.:
    // ConfigUpdate config_update = 7;    // Sent to Agent: Update your config
    // StatusQuery status_query = 8;      // Sent to Agent: Report your status
    // LogMessage log_message = 9;        // Sent from Agent: Log entry
    // ErrorReport error_report = 10;    // Sent from Agent: Report an internal error
  }
}

// Service definition for agent communication with ElizaOS (or a central orchestrator)
service AgentProtocol {
  // Registers an agent when it comes online
  rpc RegisterAgent(AgentSpec) returns (RegistrationResponse);

  // Bidirectional stream for ongoing communication (heartbeats, tasks, results)
  rpc MessageStream(stream AgentMessage) returns (stream AgentMessage);

  // Specific RPC for requesting worker specialization analysis/action
  rpc RequestSpecialization(SpecializationRequest) returns (SpecializationResponse);
  
  // Potentially add other specific RPCs if streaming isn't suitable for all interactions
  // rpc GetTask(GetTaskRequest) returns (Task); 
  // rpc UpdateTaskStatus(UpdateTaskStatusRequest) returns (google.protobuf.Empty);
} 